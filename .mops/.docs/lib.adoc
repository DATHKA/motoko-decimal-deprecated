[[module.lib]]
= lib

[[type.Decimal]]
== Decimal

[source.no-repl,motoko,subs=+macros]
----
type Decimal = { value : Int; decimals : Nat }
----

Fixed-point decimal number represented by an integer magnitude and a decimal scale.

[[type.DecimalRoundMode]]
== DecimalRoundMode

[source.no-repl,motoko,subs=+macros]
----
type DecimalRoundMode = {#down; #up; #halfUp}
----

Supported rounding strategies used throughout the module.

[[type.Result]]
== Result

[source.no-repl,motoko,subs=+macros]
----
type Result<T, E> = {#ok : T; #err : E}
----

Convenience alias mirroring Motoko's common `Result` shape.

[[type.DecimalError]]
== DecimalError

[source.no-repl,motoko,subs=+macros]
----
type DecimalError = {#DivideByZero; #InvalidFormat; #TooManyFractionDigits; #NegativeValue; #InvalidFloat; #ZeroToNegativePower}
----

Errors that can be produced by parsing and arithmetic helpers.

[[zero]]
== zero

[source.no-repl,motoko,subs=+macros]
----
func zero(decimals : Nat) : xref:#type.Decimal[Decimal]
----

Creates a zero `Decimal` with the provided scale.

[[ofInt]]
== ofInt

[source.no-repl,motoko,subs=+macros]
----
func ofInt(n : Int, decimals : Nat) : xref:#type.Decimal[Decimal]
----

Creates a `Decimal` from an `Int`, preserving the provided scale.

[[ofNat]]
== ofNat

[source.no-repl,motoko,subs=+macros]
----
func ofNat(n : Nat, decimals : Nat) : xref:#type.Decimal[Decimal]
----

Creates a `Decimal` from a `Nat`, preserving the provided scale.

[[toText]]
== toText

[source.no-repl,motoko,subs=+macros]
----
func toText(d : xref:#type.Decimal[Decimal]) : Text
----

Renders a decimal using canonical formatting (dot separator, optional sign).

[[format]]
== format

[source.no-repl,motoko,subs=+macros]
----
func format(d : xref:#type.Decimal[Decimal], opts : { thousandsSep : ?Text; decimalSep : ?Text }) : Text
----

Pretty-formats a decimal with optional custom thousands and decimal separators.

[[ofText]]
== ofText

[source.no-repl,motoko,subs=+macros]
----
func ofText(txt : Text, decimals : Nat, mode : xref:#type.DecimalRoundMode[DecimalRoundMode]) : xref:#type.Result[Result]<xref:#type.Decimal[Decimal], xref:#type.DecimalError[DecimalError]>
----

Parses textual input into a decimal with the requested scale and rounding mode.
Supports optional leading `-` and fractional part. Excess fractional digits are
rounded according to `mode`.

[[quantize]]
== quantize

[source.no-repl,motoko,subs=+macros]
----
func quantize(x : xref:#type.Decimal[Decimal], targetDecimals : Nat, rnd : xref:#type.DecimalRoundMode[DecimalRoundMode]) : xref:#type.Decimal[Decimal]
----

Rescales a decimal to `targetDecimals`, applying the supplied rounding mode.

[[truncTo]]
== truncTo

[source.no-repl,motoko,subs=+macros]
----
func truncTo(x : xref:#type.Decimal[Decimal], targetDecimals : Nat) : xref:#type.Decimal[Decimal]
----

Truncates toward zero when increasing scale.

[[floorTo]]
== floorTo

[source.no-repl,motoko,subs=+macros]
----
func floorTo(x : xref:#type.Decimal[Decimal], targetDecimals : Nat) : xref:#type.Decimal[Decimal]
----

Floors toward negative infinity when reducing scale.

[[ceilTo]]
== ceilTo

[source.no-repl,motoko,subs=+macros]
----
func ceilTo(x : xref:#type.Decimal[Decimal], targetDecimals : Nat) : xref:#type.Decimal[Decimal]
----

Ceils toward positive infinity when reducing scale.

[[toInt]]
== toInt

[source.no-repl,motoko,subs=+macros]
----
func toInt(d : xref:#type.Decimal[Decimal], mode : xref:#type.DecimalRoundMode[DecimalRoundMode]) : Int
----

Converts to an `Int` by rescaling to zero decimals using `mode`.

[[toNat]]
== toNat

[source.no-repl,motoko,subs=+macros]
----
func toNat(d : xref:#type.Decimal[Decimal], mode : xref:#type.DecimalRoundMode[DecimalRoundMode]) : xref:#type.Result[Result]<Nat, xref:#type.DecimalError[DecimalError]>
----

Attempts to convert to `Nat`, failing when the rounded integer would be negative.

[[toFloat]]
== toFloat

[source.no-repl,motoko,subs=+macros]
----
func toFloat(d : xref:#type.Decimal[Decimal]) : Float
----

Converts the decimal to a `Float` by dividing the scaled integer magnitude.

[[fromFloat]]
== fromFloat

[source.no-repl,motoko,subs=+macros]
----
func fromFloat(f : Float, decimals : Nat, mode : xref:#type.DecimalRoundMode[DecimalRoundMode]) : xref:#type.Result[Result]<xref:#type.Decimal[Decimal], xref:#type.DecimalError[DecimalError]>
----

Converts a float into a decimal, rounding according to `mode`.

[[add]]
== add

[source.no-repl,motoko,subs=+macros]
----
func add(a : xref:#type.Decimal[Decimal], b : xref:#type.Decimal[Decimal], decimals : ?Nat) : xref:#type.Decimal[Decimal]
----

Adds two decimals, aligning scales optionally to `decimals`.

[[subtract]]
== subtract

[source.no-repl,motoko,subs=+macros]
----
func subtract(a : xref:#type.Decimal[Decimal], b : xref:#type.Decimal[Decimal], decimals : ?Nat) : xref:#type.Decimal[Decimal]
----

Subtracts `b` from `a`, aligning scales optionally to `decimals`.

[[multiply]]
== multiply

[source.no-repl,motoko,subs=+macros]
----
func multiply(a : xref:#type.Decimal[Decimal], b : xref:#type.Decimal[Decimal], decimals : ?Nat, rnd : xref:#type.DecimalRoundMode[DecimalRoundMode]) : xref:#type.Decimal[Decimal]
----

Multiplies two decimals. If `decimals` is `null`, the raw scale (`a.decimals + b.decimals`) is kept.
Otherwise the product is quantized to the requested number of fractional digits using `rnd`.

[[divide]]
== divide

[source.no-repl,motoko,subs=+macros]
----
func divide(a : xref:#type.Decimal[Decimal], b : xref:#type.Decimal[Decimal], decimals : ?Nat, rnd : xref:#type.DecimalRoundMode[DecimalRoundMode]) : xref:#type.Result[Result]<xref:#type.Decimal[Decimal], xref:#type.DecimalError[DecimalError]>
----

Divides `a` by `b`, producing a decimal with the requested scale (or a default when `decimals` is `null`).

[[power]]
== power

[source.no-repl,motoko,subs=+macros]
----
func power(x : xref:#type.Decimal[Decimal], n : Int, decimals : ?Nat, rnd : xref:#type.DecimalRoundMode[DecimalRoundMode]) : xref:#type.Result[Result]<xref:#type.Decimal[Decimal], xref:#type.DecimalError[DecimalError]>
----

Raises a decimal to an integer power using fast exponentiation.
When `decimals` is `null`, positive exponents return the natural scale and negative ones fall back to the
division default; otherwise the result is quantized to `decimals` using `rnd`.

[[abs]]
== abs

[source.no-repl,motoko,subs=+macros]
----
func abs(d : xref:#type.Decimal[Decimal]) : xref:#type.Decimal[Decimal]
----

Absolute value while keeping the scale unchanged.

[[neg]]
== neg

[source.no-repl,motoko,subs=+macros]
----
func neg(d : xref:#type.Decimal[Decimal]) : xref:#type.Decimal[Decimal]
----

Returns the negation of a decimal without altering the scale.

[[isZero]]
== isZero

[source.no-repl,motoko,subs=+macros]
----
func isZero(d : xref:#type.Decimal[Decimal]) : Bool
----

Checks whether the stored magnitude is zero.

[[signum]]
== signum

[source.no-repl,motoko,subs=+macros]
----
func signum(d : xref:#type.Decimal[Decimal]) : Int
----

Returns the sign of the decimal (`-1`, `0`, `1`).

[[compare]]
== compare

[source.no-repl,motoko,subs=+macros]
----
func compare(a : xref:#type.Decimal[Decimal], b : xref:#type.Decimal[Decimal]) : Order.Order
----

Compares two decimals after aligning them to a common scale.

[[equal]]
== equal

[source.no-repl,motoko,subs=+macros]
----
func equal(a : xref:#type.Decimal[Decimal], b : xref:#type.Decimal[Decimal]) : Bool
----

Tests whether two decimals have equal value after aligning them to a common scale.

[[min]]
== min

[source.no-repl,motoko,subs=+macros]
----
func min(a : xref:#type.Decimal[Decimal], b : xref:#type.Decimal[Decimal]) : xref:#type.Decimal[Decimal]
----

Returns the minimum of two decimals.

[[max]]
== max

[source.no-repl,motoko,subs=+macros]
----
func max(a : xref:#type.Decimal[Decimal], b : xref:#type.Decimal[Decimal]) : xref:#type.Decimal[Decimal]
----

Returns the maximum of two decimals.

[[clamp]]
== clamp

[source.no-repl,motoko,subs=+macros]
----
func clamp(x : xref:#type.Decimal[Decimal], lo : xref:#type.Decimal[Decimal], hi : xref:#type.Decimal[Decimal]) : xref:#type.Decimal[Decimal]
----

Clamps `x` into the inclusive range `[lo, hi]`.

[[normalize]]
== normalize

[source.no-repl,motoko,subs=+macros]
----
func normalize(d : xref:#type.Decimal[Decimal]) : xref:#type.Decimal[Decimal]
----

Removes trailing zeros from the fractional part while preserving numeric value.

